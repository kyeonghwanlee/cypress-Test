"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAllConfigVariants = void 0;
const fs_extra_1 = require("fs-extra");
const logging_1 = require("@app-config/logging");
const node_1 = require("@app-config/node");
const config_1 = require("@app-config/config");
/**
 * Loads and validations app-config values in every environment detectable.
 *
 * Uses a hueristic to find which environments are available, because these are arbitrary.
 */
async function validateAllConfigVariants({ directory = '.', environmentAliases = node_1.defaultAliases, includeNoEnvironment = false, } = {}) {
    var _a, _b;
    // first, we have to find any applicable app-config files
    // this is less trivial than config loading, because we can't "assume" the current environment (it could be anything)
    const filesInDirectory = await (0, fs_extra_1.readdir)(directory);
    const appConfigFiles = filesInDirectory.filter((filename) => /^\.app-config\.(?:secrets\.)?(?:.*\.)?(?:yml|yaml|json|json5|toml)$/.exec(filename));
    const appConfigEnvironments = new Set();
    for (const filename of appConfigFiles) {
        // extract the environment out, which is the first capture group
        const regex = /^\.app-config\.(?:secrets\.)?(.*)\.(?:yml|yaml|json|json5|toml)$/;
        const environment = (_a = regex.exec(filename)) === null || _a === void 0 ? void 0 : _a[1];
        if (environment && environment !== 'meta' && environment !== 'schema') {
            appConfigEnvironments.add((_b = environmentAliases[environment]) !== null && _b !== void 0 ? _b : environment);
        }
    }
    await Promise.all(appConfigFiles.map(async (filename) => {
        const parsed = await new node_1.FileSource(filename).read();
        parsed.visitAll((value) => {
            var _a, _b;
            const obj = value.asObject();
            if (obj === null || obj === void 0 ? void 0 : obj.$env) {
                for (const key of Object.keys((_a = obj.$env.asObject()) !== null && _a !== void 0 ? _a : {})) {
                    appConfigEnvironments.add((_b = environmentAliases[key]) !== null && _b !== void 0 ? _b : key);
                }
            }
        });
    }));
    // remove special-cased names
    appConfigEnvironments.delete('default');
    appConfigEnvironments.delete('secrets');
    appConfigEnvironments.delete('schema');
    appConfigEnvironments.delete('meta');
    logging_1.logger.info(`Found ${appConfigEnvironments.size} environments to validate: [${Array.from(appConfigEnvironments).join(', ')}]`);
    for (const environment of appConfigEnvironments) {
        logging_1.logger.info(`Validating configuration for environment: ${environment}`);
        await (0, config_1.loadValidatedConfig)({
            directory,
            environmentOverride: environment,
            environmentVariableName: '', // do not load APP_CONFIG
        });
    }
    if (includeNoEnvironment || appConfigEnvironments.size === 0) {
        logging_1.logger.info(`Validating configuration for no environment`);
        await (0, config_1.loadValidatedConfig)({
            directory,
            environmentVariableName: '', // do not load APP_CONFIG
        });
    }
}
exports.validateAllConfigVariants = validateAllConfigVariants;
//# sourceMappingURL=validation.js.map