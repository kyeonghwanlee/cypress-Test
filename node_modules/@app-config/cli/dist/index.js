#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = void 0;
const yargs = __importStar(require("yargs"));
const execa_1 = __importDefault(require("execa"));
const clipboardy_1 = __importDefault(require("clipboardy"));
const fs_extra_1 = require("fs-extra");
const json_schema_ref_parser_1 = __importStar(require("json-schema-ref-parser"));
const common_tags_1 = require("common-tags");
const core_1 = require("@app-config/core");
const node_1 = require("@app-config/node");
const logging_1 = require("@app-config/logging");
const config_1 = require("@app-config/config");
const encryption_1 = require("@app-config/encryption");
const schema_1 = require("@app-config/schema");
const generate_1 = require("@app-config/generate");
const validation_1 = require("./validation");
var OptionGroups;
(function (OptionGroups) {
    OptionGroups["Options"] = "Options:";
    OptionGroups["General"] = "General:";
    OptionGroups["Logging"] = "Logging:";
})(OptionGroups || (OptionGroups = {}));
function subcommand(desc, run) {
    const { name, description, examples = [], options, positional } = desc;
    const [command, ...aliases] = Array.isArray(name) ? name : [name];
    return {
        command,
        aliases,
        describe: description,
        builder: (args) => {
            if (positional) {
                for (const [key, opt] of Object.entries(positional)) {
                    args.positional(key, opt);
                }
            }
            if (options) {
                args.options(options);
            }
            args.example(examples);
            return args;
        },
        async handler(args) {
            if (typeof args.cwd === 'string')
                process.chdir(args.cwd);
            if (args.verbose)
                logging_1.logger.setLevel(logging_1.LogLevel.Verbose);
            if (args.quiet)
                logging_1.logger.setLevel(logging_1.LogLevel.Error);
            if (args.silent)
                logging_1.logger.setLevel(logging_1.LogLevel.None);
            const running = Promise.resolve()
                .then(() => run(args))
                .then(() => 
            // cleanup any secret agent clients right away, so it's safe to exit
            (0, encryption_1.disconnectAgents)());
            Object.assign(args, { running });
            return running;
        },
    };
}
const noSchemaOption = {
    alias: 'q',
    type: 'boolean',
    default: false,
    description: 'Avoids doing schema validation of your app-config (dangerous!)',
    group: OptionGroups.Options,
};
const fileNameBaseOption = {
    type: 'string',
    description: 'Changes what file name prefix is used when looking for app-config files',
    group: OptionGroups.Options,
};
const environmentOverrideOption = {
    type: 'string',
    description: 'Explicitly overrides the current environment (set by APP_CONFIG_ENV | NODE_ENV | ENV)',
    group: OptionGroups.Options,
};
const secretsOption = {
    alias: 's',
    type: 'boolean',
    default: false,
    description: 'Include secrets in the output',
    group: OptionGroups.Options,
};
const prefixOption = {
    alias: 'p',
    type: 'string',
    default: 'APP_CONFIG',
    description: 'Prefix for environment variable names',
    group: OptionGroups.Options,
};
const renameVariablesOption = {
    alias: 'r',
    type: 'string',
    array: true,
    description: 'Renames environment variables (eg. HTTP_PORT=FOO)',
    group: OptionGroups.Options,
};
const aliasVariablesOption = {
    type: 'string',
    array: true,
    description: 'Like --rename, but keeps original name in results',
    group: OptionGroups.Options,
};
const onlyVariablesOption = {
    type: 'string',
    array: true,
    description: 'Limits which environment variables are exported',
    group: OptionGroups.Options,
};
const environmentVariableNameOption = {
    type: 'string',
    default: 'APP_CONFIG',
    description: 'Environment variable name to read full config from',
    group: OptionGroups.Options,
};
const formatOption = {
    alias: 'f',
    type: 'string',
    default: 'yaml',
    choices: ['yaml', 'yml', 'json', 'json5', 'toml', 'raw'],
    group: OptionGroups.Options,
};
const selectOption = {
    alias: 'S',
    type: 'string',
    description: 'A JSON pointer to select a nested property in the object',
    group: OptionGroups.Options,
};
const clipboardOption = {
    alias: 'c',
    type: 'boolean',
    description: 'Copies the value to the system clipboard',
    group: OptionGroups.Options,
};
const secretAgentOption = {
    type: 'boolean',
    default: true,
    description: 'Uses the secret-agent, if available',
    group: OptionGroups.Options,
};
async function loadConfigWithOptions({ secrets: includeSecrets, select, noSchema, fileNameBase, environmentOverride, environmentVariableName, }) {
    const options = {
        fileNameBase,
        environmentOverride,
        environmentVariableName,
    };
    let loaded;
    if (noSchema) {
        loaded = await (0, config_1.loadUnvalidatedConfig)(options);
    }
    else {
        loaded = await (0, config_1.loadValidatedConfig)(options);
    }
    const { fullConfig, parsedNonSecrets, schema } = loaded;
    let jsonConfig;
    if (includeSecrets || !parsedNonSecrets) {
        jsonConfig = fullConfig;
    }
    else {
        jsonConfig = parsedNonSecrets.toJSON();
    }
    if (select) {
        // @ts-ignore
        jsonConfig = (await json_schema_ref_parser_1.resolve.apply(json_schema_ref_parser_1.default, [jsonConfig])).get(select);
        if (jsonConfig === undefined) {
            throw new core_1.FailedToSelectSubObject(`Failed to select property ${select}`);
        }
    }
    return [jsonConfig, schema];
}
async function loadVarsWithOptions(_a) {
    var { prefix, rename, alias, only } = _a, opts = __rest(_a, ["prefix", "rename", "alias", "only"]);
    const [config, schema] = await loadConfigWithOptions(opts);
    let flattened = (0, core_1.flattenObjectTree)(config, prefix);
    flattened = (0, core_1.renameInFlattenedTree)(flattened, rename, false);
    flattened = (0, core_1.renameInFlattenedTree)(flattened, alias, true);
    if (only) {
        const filtered = {};
        for (const variable of Object.keys(flattened)) {
            if (only.includes(variable)) {
                filtered[variable] = flattened[variable];
            }
        }
        return [filtered, config, schema];
    }
    return [flattened, config, schema];
}
function fileTypeForFormatOption(option) {
    switch (option) {
        case 'json':
            return core_1.FileType.JSON;
        case 'json5':
            return core_1.FileType.JSON5;
        case 'toml':
            return core_1.FileType.TOML;
        case 'yml':
        case 'yaml':
            return core_1.FileType.YAML;
        case 'raw':
            return core_1.FileType.RAW;
        default:
            throw new core_1.AppConfigError(`${option} is not a valid file type`);
    }
}
exports.cli = yargs
    .scriptName('app-config')
    .wrap(Math.max(yargs.terminalWidth() - 5, 80))
    .strict()
    .version()
    .alias('v', 'version')
    .help('h', 'Show help message with examples and options')
    .alias('h', 'help')
    .options({
    cwd: {
        alias: 'C',
        nargs: 1,
        type: 'string',
        description: 'Run app-config in the context of this directory',
    },
})
    .options({
    verbose: {
        type: 'boolean',
        description: 'Outputs verbose messages with internal details',
    },
    quiet: {
        type: 'boolean',
        description: 'Only outputs errors that user should be aware of',
    },
    silent: {
        type: 'boolean',
        description: 'Do not print anything non-functional',
    },
})
    .group('cwd', OptionGroups.General)
    .group('help', OptionGroups.General)
    .group('version', OptionGroups.General)
    .group('verbose', OptionGroups.Logging)
    .group('quiet', OptionGroups.Logging)
    .group('silent', OptionGroups.Logging)
    .command(subcommand({
    name: ['completion [shell]', 'completions [shell]'],
    description: 'Prints bash completions',
    examples: [
        ['source <($0 completion bash)', 'Adds bash completions, put this in your bashrc'],
    ],
    positional: {
        shell: {
            type: 'string',
            demandOption: false,
            default: 'bash',
        },
    },
}, async ({ shell }) => {
    if (shell !== 'bash') {
        throw new core_1.AppConfigError('Only bash autocompletions are available');
    }
    yargs.showCompletionScript();
}))
    .command(subcommand({
    name: ['vars', 'variables', 'v'],
    description: 'Prints out the generated environment variables',
    examples: [
        ['$0 vars --secrets > .env', 'Prints all environment variables, including secret values'],
        [
            'export $($0 vars | xargs -L 1)',
            'Export the generated environment variables to the current shell',
        ],
    ],
    options: {
        secrets: secretsOption,
        prefix: prefixOption,
        rename: renameVariablesOption,
        alias: aliasVariablesOption,
        only: onlyVariablesOption,
        select: selectOption,
        noSchema: noSchemaOption,
        fileNameBase: fileNameBaseOption,
        environmentOverride: environmentOverrideOption,
        environmentVariableName: environmentVariableNameOption,
        agent: secretAgentOption,
    },
}, async (opts) => {
    (0, encryption_1.shouldUseSecretAgent)(opts.agent);
    const [env] = await loadVarsWithOptions(opts);
    process.stdout.write(Object.entries(env)
        .map(([key, value]) => `${key}=${JSON.stringify(value)}`)
        .join('\n'));
    process.stdout.write('\n');
}))
    .command(subcommand({
    name: ['create', 'c'],
    description: 'Prints out the current configuration, in a file format',
    examples: [
        ['$0 create --format json', 'Prints configuration in JSON format'],
        ['$0 create --select "#/kubernetes"', 'Prints out a section of the configuration'],
    ],
    options: {
        secrets: secretsOption,
        format: formatOption,
        select: selectOption,
        noSchema: noSchemaOption,
        fileNameBase: fileNameBaseOption,
        environmentOverride: environmentOverrideOption,
        environmentVariableName: environmentVariableNameOption,
        agent: secretAgentOption,
    },
}, async (opts) => {
    (0, encryption_1.shouldUseSecretAgent)(opts.agent);
    const [toPrint] = await loadConfigWithOptions(opts);
    process.stdout.write((0, core_1.stringify)(toPrint, fileTypeForFormatOption(opts.format), true));
    process.stdout.write('\n');
}))
    .command(subcommand({
    name: 'create-schema',
    description: 'Prints the current schema object, in a file format, with all references resolves and flattened',
    examples: [
        ['$0 create-schema --format json', 'Prints out the schema in JSON format'],
        [
            '$0 create-schema --select "#/definitions/WebServer"',
            'Prints out a specific section of the schema',
        ],
    ],
    options: {
        format: formatOption,
        select: selectOption,
    },
}, async (opts) => {
    const { schema } = await (0, schema_1.loadSchema)();
    let toPrint;
    if (opts.select) {
        // @ts-ignore
        const refs = await json_schema_ref_parser_1.resolve.apply(json_schema_ref_parser_1.default, [schema]);
        toPrint = refs.get(opts.select);
        if (toPrint === undefined) {
            throw new core_1.FailedToSelectSubObject(`Failed to select property ${opts.select}`);
        }
    }
    else {
        toPrint = schema;
    }
    process.stdout.write((0, core_1.stringify)(toPrint, fileTypeForFormatOption(opts.format), true));
    process.stdout.write('\n');
}))
    .command(subcommand({
    name: ['validate'],
    description: 'Checks all environment variants against your schema',
    options: {
        environment: {
            alias: 'env',
            type: 'string',
            description: 'Validates only using one environment',
            group: OptionGroups.Options,
        },
        includeNoEnvironment: {
            type: 'boolean',
            description: 'Validates config with no environment selected',
            group: OptionGroups.Options,
        },
    },
}, async ({ environment, includeNoEnvironment }) => {
    if (environment) {
        await (0, config_1.loadValidatedConfig)({ environmentOverride: environment });
    }
    else {
        await (0, validation_1.validateAllConfigVariants)({ includeNoEnvironment });
    }
}))
    .command(subcommand({
    name: ['generate', 'gen', 'g'],
    description: 'Run code generation as specified by meta file',
}, async () => {
    const output = await (0, generate_1.generateTypeFiles)();
    if (output.length === 0) {
        logging_1.logger.warn('No files generated - did you add the correct meta properties?');
    }
    else {
        logging_1.logger.info(`Generated: [ ${output.map(({ file }) => file).join(', ')} ]`);
    }
}))
    .command({
    command: 'secrets',
    aliases: ['secret', 's'],
    describe: 'Encryption subcommands',
    handler: () => { },
    builder: (args) => args
        .demandCommand()
        .command(subcommand({
        name: 'init',
        description: 'Initializes your encryption keychain',
        examples: [['$0 secrets init', 'Sets up your machine-local encryption key']],
    }, async () => {
        const initialized = await (0, encryption_1.initializeLocalKeys)();
        if (initialized === false) {
            throw new core_1.AppConfigError('Secrets were already initialized. Reset them if you want to create a new key.');
        }
        process.stdout.write(`\nYour app-config key was set up in ${encryption_1.keyDirs.keychain}\n\n`);
        process.stdout.write(initialized.publicKeyArmored);
        process.stdout.write('\n');
    }))
        .command(subcommand({
        name: 'init-repo',
        description: 'Creates initial symmetric key and initializes team members for a repository',
        examples: [
            [
                '$0 secrets init-repo',
                'Creates properties in meta file, making you the first trusted user',
            ],
        ],
    }, async () => {
        const myKey = await (0, encryption_1.loadPublicKeyLazy)();
        const privateKey = await (0, encryption_1.loadPrivateKeyLazy)();
        // we trust ourselves, essentially
        await (0, encryption_1.trustTeamMember)(myKey, privateKey);
        logging_1.logger.info('Initialized team members and a symmetric key');
    }))
        .command(subcommand({
        name: 'init-key',
        description: 'Creates a new symmetric key for encrypting new secrets',
        examples: [
            [
                '$0 secrets init-key',
                'Sets up a new symmetric key with the latest revision number',
            ],
        ],
    }, async () => {
        const keys = await (0, encryption_1.loadSymmetricKeys)();
        const teamMembers = await (0, encryption_1.loadTeamMembersLazy)();
        let revision;
        if (keys.length > 0) {
            revision = (0, encryption_1.latestSymmetricKeyRevision)(keys) + 1;
        }
        else {
            revision = 1;
        }
        await (0, encryption_1.saveNewSymmetricKey)(await (0, encryption_1.generateSymmetricKey)(revision), teamMembers);
        logging_1.logger.info(`Saved a new symmetric key, revision ${revision}`);
    }))
        .command(subcommand({ name: 'reset', description: 'Removes your encryption keys' }, async () => {
        const confirm = await (0, node_1.promptUser)({
            type: 'confirm',
            initial: false,
            message: "Are you sure? You won't be able to any decrypt secrets that were signed for you.",
        });
        if (confirm) {
            await (0, encryption_1.deleteLocalKeys)();
            logging_1.logger.warn('Your keys are now removed.');
        }
    }))
        .command(subcommand({ name: 'key', description: 'View your public key' }, async () => {
        process.stdout.write((await (0, encryption_1.loadPublicKeyLazy)()).armor());
    }))
        .command(subcommand({
        name: 'export <path>',
        description: 'Writes your public key to a file',
        examples: [
            [
                '$0 secrets export /mnt/my-usb/joe-blow.asc',
                'Writes your public key to a file, so it can be trusted by other users',
            ],
        ],
        positional: {
            path: {
                type: 'string',
                demandOption: true,
                description: 'File to write key to',
            },
        },
    }, async (opts) => {
        const key = await (0, encryption_1.loadPublicKeyLazy)();
        await (0, fs_extra_1.outputFile)(opts.path, key.armor());
        logging_1.logger.info(`The file ${opts.path} was written with your public key`);
    }))
        .command(subcommand({
        name: 'ci',
        description: 'Creates an encryption key that can be used without a passphrase (useful for CI)',
    }, async () => {
        logging_1.logger.info('Creating a new trusted CI encryption key');
        const { privateKeyArmored, publicKeyArmored } = await (0, encryption_1.initializeKeys)(false);
        await (0, encryption_1.trustTeamMember)(await (0, encryption_1.loadKey)(publicKeyArmored), await (0, encryption_1.loadPrivateKeyLazy)());
        process.stdout.write(`\n${publicKeyArmored}\n\n${privateKeyArmored}\n\n`);
        process.stdout.write((0, common_tags_1.stripIndents) `
                  Public and private keys are printed above.
                  To use them, add CI variables called APP_CONFIG_SECRETS_KEY and APP_CONFIG_SECRETS_PUBLIC_KEY.
                  Ensure that (especially the private key) they are "protected" variables and not visible in logs.
                `);
        process.stdout.write('\n');
    }))
        .command(subcommand({
        name: 'trust <keyPath>',
        description: 'Adds a team member who can encrypt and decrypt values',
        examples: [
            [
                '$0 secrets trust /mnt/my-usb/joe-blow.asc',
                "Trusts a new team member's public key, allowing them to encrypt and decrypt values",
            ],
        ],
        positional: {
            keyPath: {
                type: 'string',
                demandOption: true,
                description: 'Filepath of public key',
            },
        },
    }, async (opts) => {
        const key = await (0, encryption_1.loadKey)(await (0, fs_extra_1.readFile)(opts.keyPath));
        const privateKey = await (0, encryption_1.loadPrivateKeyLazy)();
        await (0, encryption_1.trustTeamMember)(key, privateKey);
        logging_1.logger.info(`Trusted ${key.getUserIds().join(', ')}`);
    }))
        .command(subcommand({
        name: 'untrust <email>',
        description: 'Revokes encryption access (in future) for a trusted team member',
        examples: [
            [
                '$0 secrets untrust joe.blow@example.com',
                'Creates a new symmetric key for all future encryption',
            ],
        ],
        positional: {
            email: {
                type: 'string',
                demandOption: true,
                description: 'User ID email address',
            },
        },
    }, async (opts) => {
        const privateKey = await (0, encryption_1.loadPrivateKeyLazy)();
        await (0, encryption_1.untrustTeamMember)(opts.email, privateKey);
    }))
        .command(subcommand({
        name: ['encrypt [secretValue]', 'enc [secretValue]', 'e [secretValue]'],
        description: 'Encrypts a secret value',
        examples: [
            ['$0 secrets encrypt "super-secret-value"', 'Encrypts the text given'],
            [`$0 secrets encrypt '{ "nested": { "object": true } }'`, 'Encrypts JSON value'],
        ],
        positional: {
            secretValue: {
                type: 'string',
                description: 'JSON value to encrypt',
            },
        },
        options: {
            clipboard: clipboardOption,
            agent: secretAgentOption,
        },
    }, async (opts) => {
        (0, encryption_1.shouldUseSecretAgent)(opts.agent);
        // load these right away, so user unlocks asap
        if (!(0, encryption_1.shouldUseSecretAgent)())
            await (0, encryption_1.loadPrivateKeyLazy)();
        let { secretValue } = opts;
        if (!secretValue) {
            if ((0, logging_1.checkTTY)()) {
                secretValue = await (0, node_1.promptUser)({
                    type: 'password',
                    message: 'Value to encrypt (can be JSON)',
                });
            }
            else {
                secretValue = await (0, node_1.consumeStdin)();
            }
        }
        if (!secretValue) {
            throw new core_1.EmptyStdinOrPromptResponse('Failed to read from stdin or prompt');
        }
        if (typeof secretValue === 'string') {
            const isJson = secretValue.startsWith('{') && secretValue.endsWith('}');
            try {
                secretValue = JSON.parse(secretValue);
            }
            catch (err) {
                if (isJson)
                    throw err;
                // only complain if it's definitely supposed to be JSON
            }
        }
        const encrypted = await (0, encryption_1.encryptValue)(secretValue);
        if (opts.clipboard) {
            await clipboardy_1.default.write(encrypted);
            process.stderr.write('Wrote encrypted text to system clipboard\n');
        }
        process.stdout.write(encrypted);
        process.stdout.write('\n');
    }))
        .command(subcommand({
        name: ['decrypt [encryptedText]', 'dec [encryptedText]', 'd [encryptedText]'],
        description: 'Decrypts a secret value',
        examples: [],
        positional: {
            encryptedText: {
                type: 'string',
                description: 'JSON value to encrypt',
                group: OptionGroups.Options,
            },
        },
        options: {
            clipboard: clipboardOption,
            agent: secretAgentOption,
        },
    }, async (opts) => {
        (0, encryption_1.shouldUseSecretAgent)(opts.agent);
        // load these right away, so user unlocks asap
        if (!(0, encryption_1.shouldUseSecretAgent)())
            await (0, encryption_1.loadPrivateKeyLazy)();
        let { encryptedText } = opts;
        if (!encryptedText && opts.clipboard) {
            encryptedText = await clipboardy_1.default.read();
            if (encryptedText)
                process.stderr.write('Read value from system clipboard\n');
        }
        if (!encryptedText) {
            if ((0, logging_1.checkTTY)()) {
                encryptedText = await (0, node_1.promptUser)({
                    type: 'password',
                    message: 'Value to decrypt',
                });
            }
            else {
                encryptedText = await (0, node_1.consumeStdin)();
            }
        }
        if (!encryptedText) {
            throw new core_1.EmptyStdinOrPromptResponse('Failed to read from stdin or prompt');
        }
        process.stdout.write(JSON.stringify(await (0, encryption_1.decryptValue)(encryptedText)));
        process.stdout.write('\n');
    }))
        .command(subcommand({
        name: 'agent',
        description: 'Starts the secret-agent daemon',
    }, async () => {
        await (0, encryption_1.startAgent)();
        // wait forever
        await new Promise(() => { });
    })),
})
    .command(subcommand({
    name: '*',
    description: 'Runs a command, with some environment variables injected (APP_CONFIG_*). Allows accessing app-config without node.js.',
    examples: [
        [
            '$0 -- docker-compose up -d',
            'Run Docker Compose with the generated environment variables',
        ],
        ['$0 -- bash-script.sh', 'Run some script, that uses $APP_CONFIG_FOO variables'],
        ['$0 -- env', 'Print environment variables, with app-config variables injected'],
        // users are directed to these examples when just running app-config, so let's show some other subcommands
        ['$0 vars --secrets', 'Prints app config environment variables, including secret values'],
        ['$0 create -f json5', 'Prints app config as a format like YAML or JSON'],
        ['$0 generate', 'Run code generation as specified by the app-config meta file'],
    ],
    options: {
        secrets: secretsOption,
        prefix: prefixOption,
        rename: renameVariablesOption,
        alias: aliasVariablesOption,
        only: onlyVariablesOption,
        format: Object.assign(Object.assign({}, formatOption), { default: 'json' }),
        select: selectOption,
        noSchema: noSchemaOption,
        fileNameBase: fileNameBaseOption,
        environmentOverride: environmentOverrideOption,
        environmentVariableName: environmentVariableNameOption,
        agent: secretAgentOption,
    },
}, async (opts) => {
    (0, encryption_1.shouldUseSecretAgent)(opts.agent);
    const [command, ...args] = opts._;
    if (!command) {
        yargs.showHelp();
        process.exit(1);
    }
    const [env, fullConfig, schema] = await loadVarsWithOptions(opts);
    // if prefix is set to something non-zero, set it as the full config
    if (opts.prefix.length > 0) {
        // this is almost always just APP_CONFIG
        const variableName = opts.prefix;
        // if we specified --only FOO, don't include APP_CONFIG
        if (!opts.only || opts.only.includes(variableName)) {
            env[variableName] = (0, core_1.stringify)(fullConfig, fileTypeForFormatOption(opts.format), true);
        }
        // this is APP_CONFIG_SCHEMA, a special variable used by programs to do their own validation
        const schemaVariableName = `${variableName}_SCHEMA`;
        if (schema && (!opts.only || opts.only.includes(schemaVariableName))) {
            env[schemaVariableName] = (0, core_1.stringify)(schema, fileTypeForFormatOption(opts.format), true);
        }
    }
    const stdio = process.env.JEST_WORKER_ID ? 'pipe' : 'inherit';
    const { stdout, stderr } = await (0, execa_1.default)(command, args, { stdio, env }).catch((err) => {
        logging_1.logger.error(err.message);
        if (err.exitCode) {
            process.exit(err.exitCode);
        }
        return Promise.reject(err);
    });
    // basically only for unit tests
    if (stdio === 'pipe') {
        process.stdout.write(stdout);
        process.stderr.write(stderr);
    }
}));
if (require.main === module) {
    exports.cli.parse();
}
//# sourceMappingURL=index.js.map