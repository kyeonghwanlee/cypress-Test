import { inspect } from 'util';
import { AppConfigError } from '@app-config/core';
import { logger } from '@app-config/logging';
import { loadValidatedConfig } from '@app-config/config';
/** Tried to read app-config value before it was loaded */
export class AccessingAppConfig extends AppConfigError {
}
// the export of this module is a proxy in front of this value
let loadedConfig;
let isMocked = false;
const assertLoaded = () => {
    if (!loadedConfig) {
        throw new AccessingAppConfig('Tried to read app-config value before calling loadConfig!');
    }
    return loadedConfig;
};
/**
 * Reads and validates app-config, using the default loading strategy.
 * Same as `loadValidatedConfig` but stores loaded config in the `config` export.
 */
export async function loadConfig(options, schemaOptions) {
    if (loadedConfig) {
        logger.warn('Called loadConfig, even though config was already loaded elsewhere');
        if (isMocked) {
            throw new AppConfigError(`Called loadConfig after config was mocked with mockConfig!`);
        }
    }
    const { fullConfig } = await loadValidatedConfig(options, schemaOptions);
    loadedConfig = fullConfig;
    return config;
}
/**
 * Singleton for loaded configuration, when `loadConfig` has completed successfully.
 *
 * Reading properties on this object before `loadConfig` completes will throw errors.
 */
export const config = new Proxy({
    APP_CONFIG_WAS_NOT_LOADED_YET_LOOK_AT_THE_DOCS: true,
    [inspect.custom]() {
        return inspect(assertLoaded());
    },
    toJSON() {
        return assertLoaded();
    },
}, {
    ownKeys() {
        return Reflect.ownKeys(assertLoaded());
    },
    has(_, key) {
        return key in assertLoaded();
    },
    get(_, prop) {
        return Reflect.get(assertLoaded(), prop);
    },
    getOwnPropertyDescriptor(_, key) {
        return Object.getOwnPropertyDescriptor(assertLoaded(), key);
    },
    set() {
        throw new AppConfigError('Setting properties on app-config is not allowed');
    },
    defineProperty() {
        throw new AppConfigError('Setting properties on app-config is not allowed');
    },
    deleteProperty() {
        throw new AppConfigError('Deleting properties from app-config is not allowed');
    },
});
export default config;
/**
 * ONLY available when using @app-config/webpack. Validates configuration using AJV.
 */
export const validateConfig = null; // eslint-disable-line
export { ParsedValue, ConfigSource, LiteralSource, CombinedSource, FallbackSource, FileType, stringify, filePathAssumedType, parseRawString, } from '@app-config/core';
export { setLogLevel, LogLevel } from '@app-config/logging';
export { loadValidatedConfig, loadUnvalidatedConfig, } from '@app-config/config';
export { loadSchema } from '@app-config/schema';
export { loadMetaConfig } from '@app-config/meta';
export { currentEnvironment, defaultAliases, FileSource, FlexibleFileSource, EnvironmentSource, } from '@app-config/node';
export { environmentVariableSubstitution, envDirective, extendsDirective, extendsSelfDirective, overrideDirective, } from '@app-config/extensions';
export { default as encryptedDirective } from '@app-config/encryption';
export { defaultExtensions, defaultEnvExtensions, defaultMetaExtensions, } from '@app-config/default-extensions';
/** @hidden Please don't rely on this. */
export function resetConfigInternal() {
    loadedConfig = undefined;
}
/**
 * Overrides the configuration internally, setting it to the provided override.
 */
export function mockConfig(override) {
    loadedConfig = override;
    isMocked = true;
    return () => {
        loadedConfig = undefined;
        isMocked = false;
    };
}
//# sourceMappingURL=index.js.map